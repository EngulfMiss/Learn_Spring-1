# 代理模式
代理模式的分类:
- 静态代理
- 动态代理

## 静态代理
角色分析:  
- 抽象角色：一般使用接口或抽象类
- 真实角色：被代理的角色
- 代理角色：代理真实角色，代理真实角色后，我们一般会做一些额外操作
- 客户：访问代理对象的人

代码步骤:
1. 接口
```java
//抽象角色  租房
public interface Rent {
    public abstract void rent();
}
```
2. 真实角色
```java
public class Host implements Rent{
    public void rent() {
        System.out.println("房东要出租房子");
    }
}
```
3. 代理角色
```java
public class Proxy implements Rent {
    private Host host;

    public Proxy() {
    }

    public Proxy(Host host) {
        this.host = host;
    }

    public void rent() {
        System.out.println("我是中介");
        seeHouse();
        host.rent();
    }

    public void seeHouse(){
        System.out.println("中介带你看房");
    }
}
```
4. 客户
```java
public class Client {
    public static void main(String[] args) {
        Host host = new Host();
        Proxy proxy = new Proxy(host);
        proxy.rent();

        /*Host host = new Host();
        host.rent();*/
    }
}
```

代理模式的好处：  
- 可以使真实角色的操作更加纯粹，不用去关注一些公共的业务
- 公共业务交给了代理角色，实现了业务的分工
- 公共业务发生扩展的时候，方便集中的管理

缺点：  
- 一个真实角色就会产生一个代理角色，开发效率会降低

## 动态代理
- 动态代理的代理类是动态生成的
- 动态代理分为两大类：基于接口的动态代理，基于类的动态代理
  - 基于接口 --- JDK动态代理
  - 基于类 --- cglib

需要了解两个类：  
Proxy 和 InvocationHandler

- InvocationHandler
```java
//我们需要用这个类 自动生成代理类
public class ProxyInvocationHandler implements InvocationHandler {

    //需要实现的接口
    private Rent rent;

    public void setRent(Rent rent) {
        this.rent = rent;
    }

    //生成得到代理类
    public Object getProxyInstance(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(), this);
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        seeHouse();
        //动态代理的本质，就是使用反射机制
        Object result = method.invoke(rent, args);

        return result;
    }

    public void seeHouse(){
        System.out.println("带你看看房子");
    }
}
```
